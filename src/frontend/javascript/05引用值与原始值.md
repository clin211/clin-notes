# 引用值与原始值

本文内容：
- 立即对象
- 基本 JavaScript 数据类型
- 引用值与原始值的包装类型

引用值（或者对象）是某个特定引用类型的实例。对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（`constructor`）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：

```js
const now = new Date();
```
这行代码创建了引用类型 `Date` 的一个新实例，并将它保存在变量 `now` 中。`Date()` 在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。

## Date

创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。`Date` 类型将日期保存为自协调世界时（[UTC，Universal Time Coordinated](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6)）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，`Date` 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。

要创建日期对象，就使用 new 操作符来调用 Date 构造函数：
```js
const now = new Date();
```

`Date()` 构造函数有四种基本形式：
> - `year` 表示**年份**的整数值。0 到 99 会被映射至 1900 年至 1999 年，其他值代表实际年份。
> - `monthIndex` 表示**月份**的整数值，从 0（1 月）到 11（12 月）。
> - `day` 表示一个月中的**第几天**的整数值，从 1 开始；默认值为 1。
> - `hours` 表示一天中的**小时数**的整数值 (24 小时制)；默认值为 0（午夜）。
> - `minutes` 表示一个完整时间中的**分钟**部分的整数值；默认值为 0。
> - `seconds` 表示一个完整时间中的**秒**部分的整数值；默认值为 0。
> - `milliseconds` 表示一个玩这个时间的**毫秒**部分的整数值；默认值为 0。

- **不传递任何参数**：创建一个代表当前日期和时间的 Date 对象。
  ```js
  // new Date();
  let now = new Date();
  ```
- **传递一个表示日期的字符串**：创建一个对应于该字符串描述的日期和时间的 Date 对象。字符串的格式应该可以被 `Date.parse()` 方法接受。
  ```js
  // new Date(dateString);
  let someDate = new Date("July 7, 2024 07:07:07");
  ```
- **传递年、月和日**：创建一个对应于指定日期和时间的 Date 对象。年份是四位数字，月份是 0-11（0代表一月），日期是1-31。
  ```js
  // new Date(value);
  let someDate2 = new Date(2024, 6, 7);
  ```
- **传递年、月、日、小时、分钟、秒和毫秒**：创建一个对应于指定日期和时间的Date对象。年份是四位数字，月份是0-11（0代表一月），日期是1-31，小时是0-23，分钟和秒都是0-59，毫秒是0-999。
  ```js
  // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);
  let someDate3 = new Date(2024, 6, 7, 7, 7, 7, 7);
  ```
这些都是创建 Date 对象的方式，每种方式都根据所给参数的不同，会返回代表不同日期和时间的 Date 对象。

> Tips：
> - 在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间
> - 要给予其他日期和时间创建日期对象时，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数），可以使用 `Date.parse()` 和 `Date.UTC()` 两个辅助方法

如果传给 `Date.parse()` 的字符串并不表示日期，则该方法会返回 `NaN`。如果直接把表示日期的字符串传给 `Date` 构造函数，那么 `Date` 会在后台调用 `Date.parse()`。换句话说，下面这两是等价的：
```js
const someDate = new Date("May 23, 2024"); // ==> const someDate = new Date(Date.parse("May 23, 2024"));
```
得到的日期对象相同。

`Date.UTC()` 方法也返回日期的毫秒表示，但使用的是跟 `Date.parse()` 不同的信息来生成这个值。传给 `Date.UTC()` 的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 `Date.UTC()` 的两个例子：
```js
// GMT 时间 2024 年 4 月 1 日零点
const y2k = new Date(Date.UTC(2024, 3));
console.log(y2k); // Mon Apr 01 2024 08:00:00 GMT+0800 (中国标准时间)

// GMT 时间 2024 年 4 月 5 日下午 5 点 55 分 55 秒
const allFives = new Date(Date.UTC(2024, 3, 5, 17, 55, 55));
console.log(allFives); // Sat Apr 06 2024 01:55:55 GMT+0800 (中国标准时间)
```

这个例子创建了两个日期 。第一个日期是 2024 年 4 月 1 日零点（GMT），2024 代表年，3 代表月（1 月）。因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点。第二个日期表示 2024 年 4 月 5 日下午 5 点 55 分 55 秒（GMT）。虽然日期里面涉及的都是 4，但月数必须用 3，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。其他参数就都很直观了。

与 `Date.parse()` 一样，`Date.UTC()` 也会被 `Date` 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。不过 `Date` 构造函数跟 `Date.UTC()` 接收的参数是一样的。因此，如果第一个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此类推。上面的例子也可以这样写：
```js
// GMT 时间 2024 年 4 月 1 日零点
const y2k = new Date(2024, 3);
console.log(y2k); // Mon Apr 01 2024 00:00:00 GMT+0800 (中国标准时间)

// GMT 时间 2024 年 4 月 5 日下午 5 点 55 分 55 秒
const allFives = new Date(2024, 3, 5, 17, 55, 55);
console.log(allFives); // Fri Apr 05 2024 17:55:55 GMT+0800 (中国标准时间)
```
以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（**由于系统设置决定的**）本地时区的日期。

ECMAScript 还提供了 `Date.now()` 方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：
```js
// 起始时间
let start = Date.now();

// 调用函数
doSomething();

// 结束时间
let stop = Date.now(),
    result = stop - start;
```

### 继承的方法

与其他类型一样，Date 类型重写了 `toLocaleString()`、`toString()` 和 `valueOf()` 方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 `toLocaleString()` 方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。`toString()` 方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。

下面给出了 `toLocaleString()` 和 `toString()` 返回的 2024 年 4 月 22 日零点的示例（地区为"en-US"的 PST，即 Pacific Standard Time，太平洋标准时间）：
```js
let date = new Date(Date.UTC(2024, 3, 22));  // 创建一个日期对象，表示2024年4月22日零点（UTC）

// 使用 toLocaleString() 方法，会返回一个根据当前地区设置的日期和时间字符串
let dateLocaleString = date.toLocaleString("en-US", { timeZone: "PST" });
console.log(dateLocaleString);  // 输出："4/21/2024, 5:00:00 PM"，因为PST比UTC早8小时

// 使用 toString() 方法，会返回一个包含日期、时间和时区的字符串
let dateString = date.toString();
console.log(dateString);  // 输出："Sun Apr 22 2024 00:00:00 GMT+0000 (UTC)"
```
在这个示例中，我们首先创建了一个 `Date` 对象，表示 2024 年 4 月 22 日零点（UTC）。然后我们使用 `toLocaleString()` 和 `toString()` 方法将这个Date对象转换为字符串。注意，`toLocaleString()` 方法的输出取决于当前的地区设置。在这个示例中，我们将地区设置为`"en-US"`，并设置时区为 `"PST"`。因此，输出的日期和时间是根据太平洋标准时间来表示的。而 `toString()` 方法返回的字符串总是使用UTC（协调世界时）来表示日期和时间。

**Date 类型的 `valueOf()` 方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示**。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：
```js
let date1 = new Date(2024, 3, 22);  // 创建一个日期对象，表示2024年4月22日
let date2 = new Date(2025, 3, 22);  // 创建另一个日期对象，表示2025年4月22日

console.log(date1.valueOf());  // 输出：1713715200000，这是date1的毫秒表示
console.log(date2.valueOf());  // 输出：1745251200000，这是date2的毫秒表示

console.log(date1 < date2);     // true
console.log(date1 > date2);     // false
console.log(date1 == date2);    // false
console.log(date1 === date2);   // false
```

### 日期格式化
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：
- toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
  ```js
  let date = new Date(2024, 3, 22, 13, 24, 0);  // 创建一个日期对象，表示2024年4月22日13:24:00
  console.log(date.toDateString());  // 输出："Mon Apr 22 2024"
  ```
- toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
  ```js
  let date = new Date(2024, 3, 22, 13, 24, 0);  // 创建一个日期对象，表示2024年4月22日13:24:00
  console.log(date.toTimeString());  // 输出："13:24:00 GMT+0800 (China Standard Time)"
  ```
- toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
  ```js
  let date = new Date(2024, 3, 22, 13, 24, 0);  // 创建一个日期对象，表示2024年4月22日13:24:00
  console.log(date.toLocaleDateString());  // 输出："4/22/2024"
  ```
- toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
  ```js
  let date = new Date(2024, 3, 22, 13, 24, 0);  // 创建一个日期对象，表示2024年4月22日13:24:00
  console.log(date.toLocaleTimeString());  // 输出："1:24:00 PM"
  ```
- toUTCString()显示完整的 UTC 日期（格式特定于实现）。
  ```js
  let date = new Date(2024, 3, 22, 13, 24, 0);  // 创建一个日期对象，表示2024年4月22日13:24:00
  console.log(date.toUTCString());  // 输出："Mon, 22 Apr 2024 05:24:00 GMT"
  ```
这些方法的输出与 `toLocaleString()` 和 `toString()` 一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。
> 还有一个方法叫 `toGMTString()`，这个方法跟 `toUTCString()` 是一样的，目的是为了向后兼容。不过，规范建议新代码使用 `toUTCString()`。**这些方法的输出可能会因浏览器和操作系统的不同而有所不同**。这是因为**这些方法的实现取决于浏览器和操作系统的国际化设置**。因此，如果你需要在用户界面上一致地显示日期，可能需要使用一些专门的日期格式化库，比如：[day.js](https://day.js.org/)。

### 日期/时间组件方法
Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。

| 方法                             | 说明                                                                                                       |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| getTime()                        | 返回日期的毫秒表示；与 valueOf() 相同                                                                      |
| setTime(milliseconds)            | 设置日期的毫秒表示，从而修改整个日期                                                                       |
| getFullYear()                    | 返回 4 位数年（即 2019 而不是 19）                                                                         |
| getUTCFullYear()                 | 返回 UTC 日期的 4 位数年                                                                                   |
| setFullYear(year)                | 设置日期的年（year 必须是 4 位数）                                                                         |
| setUTCFullYear(year)             | 设置 UTC 日期的年（year 必须是 4 位数）                                                                    |
| getMonth()                       | 返回日期的月（0 表示 1 月，11 表示 12 月）                                                                 |
| getUTCMonth()                    | 返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）                                                            |
| setMonth(month)                  | 设置日期的月（month 为大于 0 的数值，大于 11 加年）                                                        |
| setUTCMonth(month)               | 设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）                                                   |
| getDate()                        | 返回日期中的日（1~31）                                                                                     |
| getUTCDate()                     | 返回 UTC 日期中的日（1~31）                                                                                |
| setDate(date)                    | 设置日期中的日（如果 date 大于该月天数，则加月）                                                           |
| setUTCDate(date)                 | 设置 UTC 日期中的日（如果 date 大于该月天数，则加月）                                                      |
| getDay()                         | 返回日期中表示周几的数值（0 表示周日，6 表示周六）                                                         |
| getUTCDay()                      | 返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）                                                    |
| getHours()                       | 返回日期中的时（0~23）                                                                                     |
| getUTCHours()                    | 返回 UTC 日期中的时（0~23）                                                                                |
| setHours(hours)                  | 设置日期中的时（如果 hours 大于 23，则加日）                                                               |
| setUTCHours(hours)               | 设置 UTC 日期中的时（如果 hours 大于 23，则加日）                                                          |
| getMinutes()                     | 返回日期中的分（0~59）                                                                                     |
| getUTCMinutes()                  | 返回 UTC 日期中的分（0~59）                                                                                |
| setMinutes(minutes)              | 设置日期中的分（如果 minutes 大于 59，则加时）                                                             |
| setUTCMinutes(minutes)           | 设置 UTC 日期中的分（如果 minutes 大于 59，则加时）                                                        |
| getSeconds()                     | 返回日期中的秒（0~59）                                                                                     |
| getUTCSeconds()                  | 返回 UTC 日期中的秒（0~59）                                                                                |
| setSeconds(seconds)              | 设置日期中的秒（如果 seconds 大于 59，则加分）                                                             |
| setUTCSeconds(seconds)           | 设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）                                                        |
| getMilliseconds()                | 返回日期中的毫秒                                                                                           |
| getUTCMilliseconds()             | 返回 UTC 日期中的毫秒                                                                                      |
| setMilliseconds(milliseconds)    | 设置日期中的毫秒                                                                                           |
| setUTCMilliseconds(milliseconds) | 设置 UTC 日期中的毫秒                                                                                      |
| getTimezoneOffset()              | 返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异） |

## RegExp
**正则表达式是用于匹配字符串中字符组合的模式。** 在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 `exec` 和 `test` 方法，以及 String 的 `match`、`matchAll`、`replace`、`search` 和 `split` 方法。
```js
let expression = /pattern/flags;
```

这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。
| 标记符 | 说明                                                                 |
| ------ | -------------------------------------------------------------------- |
| g      | 全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束 |
| i      | 不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写          |
| m      | 多行模式，表示查找到一行文本末尾时会继续查找                         |
| y      | 粘附模式，表示只查找从 lastIndex 开始及之后的字符串                  |
| u      | Unicode 模式，启用 Unicode 匹配                                      |
| s      | dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）                  |

使用不同模式和标记可以创建出各种正则表达式，比如：
```js
// 匹配字符串中的所有"at"
let pattern1 = /at/g;

// 匹配第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
```

与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括 `( [ { \ ^ $ | ) ] } ? * + .`；元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：
```js
let pattern1 = /[bc]at/i;
// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;

// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
```
这里的 pattern1 匹配"bat"或"cat"，不区分大小写。要直接匹配"[bc]at"，左右中括号都必须像 pattern2 中那样使用反斜杠转义。在 pattern3 中，点号表示"at"前面的任意字符都可以匹配。如果想匹配".at"，那么要像 pattern4 中那样对点号进行转义。

**正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串**。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：
```js
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;

// 跟 pattern1 一样，只不过是用构造函数创建的
let pattern2 = new RegExp("[bc]at", "i");
```
这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，在正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串：
| 字面量模式       | 对应的字符串          |
| ---------------- | --------------------- |
| /\[bc\]at/       | "\\[bc\\]at"          |
| /\.at/           | "\\.at"               |
| /name\/age/      | "name\\/age"          |
| /\d.\d{1,2}/     | "\\d.\\d{1,2}"        |
| /\w\\hello\\123/ | "\\w\\\\hello\\\\123" |

此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：
```js
const re1 = /cat/g;
console.log(re1); // "/cat/g"

const re2 = new RegExp(re1);
console.log(re2); // "/cat/g"

const re3 = new RegExp(re1, "i");
console.log(re3); // "/cat/i"
```

## 原始值包装类型
在JavaScript中，有一些特殊的类型叫做引用类型，包括 `Boolean`（布尔值）、`Number`（数字）和 `String`（字符串）。这些类型都有一些特殊的行为，与我们在其他情况下使用的原始值相对应。每当我们需要使用原始值的方法或属性时，JavaScript会在后台为我们创建一个对应的“包装对象”。这样，我们就可以使用这些方法来操作原始值了。
```js
let s1 = "some text";
let s2 = s1.substring(2);
```
在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：
1. 创建一个 String 类型的实例；
2. 调用实例上的特定方法；
3. 销毁实例

可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：
```js
let s1 = new String('some text');
const s2 = s1.substring(2);
s1 = null;
```
这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过使用的是 `Boolean` 和 `Number` 包装类型而已。

**引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。** 比如下面的例子：
```js
let s1 = "some text";
s1.color = "red";
console.log(s1.color); // undefined
```
这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。接着访问 color 属性时，它却不见了。原因就是第二行代码运行时会临时创建一个 `String` 对象，而当第三行代码执行时，这个对象已经被销毁了。

可以显式地使用 `Boolean`、`Number` 和 `String` 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 `typeof` 会返回 `"object"`，所有原始值包装对象都会转换为布尔值 `true`。

另外，`Object` 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：
```js
let obj = new Object("some text");
console.log(obj instanceof String); // true
```
如果传给 `Object` 的是字符串，则会创建一个 `String` 的实例。如果是数值，则会创建 `Number` 的实例。布尔值则会得到 `Boolean` 的实例。
注意，使用 `new` 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：
```js
let value = "25";
let number = Number(value); // 转型函数
console.log(typeof number); // "number"
let obj = new Number(value); // 构造函数
console.log(typeof obj); // "object"
```
在这个例子中，变量 `number` 中保存的是一个值为 25 的原始数值，而变量 obj 中保存的是一个
Number 的实例。

虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。

### Boolean
Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 `true` 或 `false`；示例如下：
```js
const booleanObject = new Boolean(true);
```

Boolean 的实例会重写 `valueOf()` 方法，返回一个原始值 `true` 或 `false`。`toString()` 方法被调用时也会被覆盖，返回字符串 `"true"` 或 `"false"`。不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：
```js
let falseObject = new Boolean(false);
let result = falseObject && true;
console.log(result); // true

let falseValue = false;
result = falseValue && true;
console.log(result); // false
```
首先，`let falseObject = new Boolean(false);` 创建了一个Boolean包装对象，其值为 `false`。然后，`let result = falseObject && true;` 这行代码*判断 falseObject（**一个对象**）和 `true`之间的逻辑与关系*。在JavaScript中，对象（包括包装对象）在布尔上下文中被视为真值，因此`falseObject && true` 的结果是true。

在第二部分，`let falseValue = false;` 创建了一个原始的布尔值 `false`，然后 `result = falseValue && true;` 这行代码**判断 falseValue（**一个原始的布尔值**）和 `true` 之间的逻辑与关系**。因为 `falseValue` 的值是 `fals`e，所以 `falseValue && true` 的结果是false。所以虽然 `falseObject` 和 `falseValue` 看起来有相同的值，但由于它们是不同类型（一个是对象，一个是原始值），在逻辑与操作中表现出了不同的结果。

原始值和引用值（如Boolean对象）在JavaScript中是有很大区别的。以下是一些主要的区别：
- 存储方式：这个概念是在底层实现的，我们在JavaScript代码中看不到直接的示例。但是要知道原始值存储在栈中，引用值存储在堆中，并由栈中的一个指针指向它。
  ```js
  let a = 1;
  let b = a;
  b = 2;
  console.log(a); // 输出 1, a的值没有改变

  let obj1 = new Boolean(false);
  let obj2 = obj1;
  obj2.valueOf = function(){ return true; };
  console.log(obj1.valueOf()); // 输出 true, obj1的值被改变了
  ```
- 比较方式：
  ```js
  let a = 1;
  let b = 1;
  console.log(a === b); // 输出 true

  let obj1 = new Boolean(false);
  let obj2 = new Boolean(false);
  console.log(obj1 === obj2); // 输出 false
  ```
- 变动性：
  ```js
  let a = 1;
  a.prop = true;
  console.log(a.prop); // 输出 undefined, 不能给原始值添加属性

  let obj1 = new Boolean(false);
  obj1.prop = true;
  console.log(obj1.prop); // 输出 true, 可以给引用值添加属性
  ```
- 方法和属性：
  ```js
  let a = "hello";
  console.log(a.toUpperCase()); // 输出 "HELLO", JavaScript自动创建了一个临时的String对象

  let obj1 = new Boolean(false);
  console.log(obj1.valueOf()); // 输出 false, 引用值可以直接调用方法
  ```

### Number
Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：
```js
const numberObject = new Number(10);
```

与 Boolean 类型一样，Number 类型重写了 `valueOf()`、`toLocaleString()` 和 `toString()` 方法。`valueOf()` 方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。`toString()` 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：
```js
// 创建一个原始数值
let num = 10;

// 使用toString()方法将数值转换为十进制字符串表示
console.log(num.toString()); // 输出 "10"

// 使用toString()方法并传入2作为参数，将数值转换为二进制字符串表示
console.log(num.toString(2)); // 输出 "1010"

// 使用toString()方法并传入8作为参数，将数值转换为八进制字符串表示
console.log(num.toString(8)); // 输出 "12"

// 使用toString()方法并传入10作为参数，将数值转换为十进制字符串表示
console.log(num.toString(10)); // 输出 "10"

// 使用toString()方法并传入16作为参数，将数值转换为十六进制字符串表示
console.log(num.toString(16)); // 输出 "a"
```
除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。
- `toFixed()` 方法返回包含指定小数点位数的数值字符串，如：
  ```js
  let num = 10;
  console.log(num.toFixed(2)); // "10.00"
  ```
  这里的 `toFixed()` 方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为"10.00"，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：
  ```js
  let num = 10.005;
  console.log(num.toFixed(2)); // "10.01"
  ```
  `toFixed()` 自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，`0.1 + 0.2 = 0.30000000000000004`。

- 用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。如：
  ```js
  let num = 10;
  console.log(num.toExponential(1)); // "1.0e+1"
  ```
  这段代码的输出为 `"1.0e+1"`。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 `toPrecision()`。`toPrecision()` 方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：
  ```js
  // 创建一个原始数值
  let num = 99;

  // 使用toPrecision()方法并传入1作为参数，将数值转换为长度为1的字符串表示
  // 由于99的长度超过了1，因此结果以科学记数法表示
  console.log(num.toPrecision(1)); // 输出 "1e+2"

  // 使用toPrecision()方法并传入2作为参数，将数值转换为长度为2的字符串表示
  console.log(num.toPrecision(2)); // 输出 "99"

  // 使用toPrecision()方法并传入3作为参数，将数值转换为长度为3的字符串表示
  // 由于99的长度小于3，因此在末尾添加了一个零以满足长度要求
  console.log(num.toPrecision(3)); // 输出 "99.0"
  ```
  > toPrecision()方法可以表示带 1~21 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围

与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。在处理原始数值和引用数值时，`typeof` 和 `instacnceof` 操作符会返回不同的结果，如下所示：
```js
// 创建一个数值对象
let numberObject = new Number(10);

// 创建一个原始数值
let numberValue = 10;

// 使用typeof运算符检查数值对象的类型，结果是"object"
console.log(typeof numberObject); // 输出 "object"

// 使用typeof运算符检查原始数值的类型，结果是"number"
console.log(typeof numberValue); // 输出 "number"

// 使用instanceof运算符检查数值对象是否是Number的实例，结果是true
console.log(numberObject instanceof Number); // 输出 true

// 使用instanceof运算符检查原始数值是否是Number的实例，结果是false
// 因为原始数值不是对象，所以不能是Number的实例
console.log(numberValue instanceof Number); // 输出 false
```
原始数值在调用 `typeof` 时始终返回 `"number"`，而 Number 对象则返回 `"object"`。类似地，Number 对象是 Number 类型的实例，而原始数值不是。

#### isInteger()方法与安全整数
ES6 新增了 `Number.isInteger()` 方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0 可能会让人误以为数值是一个浮点值：
```js
console.log(Number.isInteger(1)); // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false
```
IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（-2^53 + 1）到 `Number.MAX_SAFE_INTEGER（2^53 - 1`）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用 `Number.isSafeInteger()` 方法：
```js
// 检查 -2^53 是否是安全整数，结果是false，因为-2^53超出了安全整数的范围
console.log(Number.isSafeInteger(-1 * (2 ** 53))); // 输出 false

// 检查 -2^53 + 1 是否是安全整数，结果是true，因为-2^53 + 1在安全整数的范围内
console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // 输出 true

// 检查 2^53 是否是安全整数，结果是false，因为2^53超出了安全整数的范围
console.log(Number.isSafeInteger(2 ** 53)); // 输出 false

// 检查 2^53 - 1 是否是安全整数，结果是true，因为2^53 - 1在安全整数的范围内
console.log(Number.isSafeInteger((2 ** 53) - 1)); // 输出 true
```

### String